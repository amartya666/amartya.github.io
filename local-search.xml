<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>thinkOS for the first day</title>
    <link href="/2020/08/09/thinkOS%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0day1/"/>
    <url>/2020/08/09/thinkOS%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0day1/</url>
    
    <content type="html"><![CDATA[<h2 id="Preface："><a href="#Preface：" class="headerlink" title="Preface："></a>Preface：</h2><p>Usually the goal of OS class is to expose students to the design and implementation of operating systems.</p><p>If this book is successful, it should give you a better understanding of what is happening when programs run, and what you can do to make them run better and faster.</p><h2 id="chapter-1-Compilation"><a href="#chapter-1-Compilation" class="headerlink" title="chapter 1 Compilation"></a>chapter 1 Compilation</h2><h3 id="1-1-Compiled-and-interpreted-languages"><a href="#1-1-Compiled-and-interpreted-languages" class="headerlink" title="1.1 Compiled and interpreted languages"></a>1.1 Compiled and interpreted languages</h3><p>“Compiled” means that programs are translated into machine language and then executed by hardware; “interpreted” means that programs are read and executed by a software interpreter.</p><p>First, many languages can be either compiled or interpreted. Second, there are languages like Java that use a hybrid approach.</p><p>So being compiled or interpreted is not an intrinsic characteristic of a language;</p><h3 id="1-2-Static-types"><a href="#1-2-Static-types" class="headerlink" title="1.2 Static types"></a>1.2 Static types</h3><p>Many interpreted languages support dynamic types, but compiled languages are usually limited to static types.</p><p>In a statically-typed language, you can tell by looking at the program what type each variable refers to.</p><p>In a dynamically-typed language, you don’t always know the type of a variable until the program is running.</p><p>There are many differences in functions written by C and Python. The main difference is type declarations.</p><p>These checks before executing don’t have to happen at run time, which is one of the reasons compiled languages generally run faster than interpreted languages. </p><p>Declaring types at compile time also saves space. In dynamic languages, variable names are stored in memory while the program runs. In compiled languages, variable names exist at compile-time but not at run time. The compiler chooses a location for each variable and records these locations as part of the compiled program.</p><p>1.3 The compilation process</p><p>As a programmer, you should have a mental model of what happens during compilation. If you understand the process, it will help you interpret error messages, debug your code, and avoid common pitfalls.</p><p>preprocessing    parsing     static checking     code generation     linking     optimization</p><p>1.4 Object Code</p><p>1.5 Assembly code</p><p>1.6 Preprocessing</p><p>1.7 Errors</p><p>From preprocessor, compiler, linker.</p>]]></content>
    
    
    <categories>
      
      <category>Operating System</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>thinkOS for the second day</title>
    <link href="/2020/08/09/thinkOS%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0day2/"/>
    <url>/2020/08/09/thinkOS%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0day2/</url>
    
    <content type="html"><![CDATA[<h2 id="Preface："><a href="#Preface：" class="headerlink" title="Preface："></a>Preface：</h2><p>If this book is successful, it should give you a better understanding of what is happening when programs run, and what you can do to make them run better and faster.</p><h2 id="chapter-2-Processes"><a href="#chapter-2-Processes" class="headerlink" title="chapter 2 Processes"></a>chapter 2 Processes</h2><h3 id="2-1-Abstraction-and-virtualization"><a href="#2-1-Abstraction-and-virtualization" class="headerlink" title="2.1 Abstraction and virtualization"></a>2.1 Abstraction and virtualization</h3><ul><li>Abstraction: An abstraction is a simplified representation of something complicated.</li><li>Virtualization: An important kind of abstraction is virtualization, which is the process of creating a desirable illusion. In the context of virtualization, we sometimes call what is really happening “physical”, and what is virtually happening either “logical” or “abstract”.</li></ul><h3 id="2-2-Isolation"><a href="#2-2-Isolation" class="headerlink" title="2.2 Isolation"></a>2.2 Isolation</h3><p>when you are designing a system with multiple components, it is usually a good idea to isolate them from each other so that a change in one component doesn’t have undesired effects on other components. One of the most important goals of an operating system is to isolate each running program from the others.</p><p>The software object that provides this isolation is a process.</p><p>A process is a software object that represents a running program.</p><p>A process is an object that contains the following data:</p><ul><li>The text of the program, usually a sequence of machine language instructions.</li><li>Data associated with the program, including static data (allocated at compile time) and dynamic data (allocated at run time).</li><li>The state of any pending input/output operations.</li><li>The hardware state of the program.</li></ul><p>Usually one process runs one program, but it is also possible for a process to load and run a new program. It is also possible, and common, to run the same program in more than one process. In that case, the processes share the same program text but generally have different data and hardware states.</p><p>Most operating systems provide a fundamental set of capabilities to isolate processes from each other:</p><ul><li>Multitasking. interrupt a running process at almost any time, save its hardware state, and then resume the process later</li><li>Virtual memory. create the illusion that each process has its own chunk of memory, isolated from all other processes.</li><li>Device abstraction. It is up to the operating system to maintain order by providing appropriate abstractions.</li></ul><p>comments: I never thought it is so hard for two processes to communicate  before realizing that they should be isolated from each other.</p><h3 id="2-3-Unix-processes"><a href="#2-3-Unix-processes" class="headerlink" title="2.3 Unix processes"></a>2.3 Unix processes</h3><p>kthreadd     kworker     ksoftirqd</p><h2 id="chapter-3-Virtual-memory"><a href="#chapter-3-Virtual-memory" class="headerlink" title="chapter 3 Virtual memory"></a>chapter 3 Virtual memory</h2><h3 id="3-1-A-bit-of-information-theory"><a href="#3-1-A-bit-of-information-theory" class="headerlink" title="3.1 A bit of information theory"></a>3.1 A bit of information theory</h3><p>A bit is a binary digit; it is also a unit of information.</p><p>Suppose I flip a coin and tell you the outcome. I have given you one bit of information. If I roll a six-sided die and tell you the outcome, I have given you log6 bits of information. And in general, if the probability of the outcome is p, then the information content is -logp.</p><p>This quantity is called the self-information of the outcome. It measures how surprising the outcome is, which is why it is also called surprisal.</p><p>Intuitively, unexpected news carries a lot of information; conversely, if there is something you were already confident of, conforming it contributes only a small amount of information.</p><h3 id="3-2-Memory-and-storage"><a href="#3-2-Memory-and-storage" class="headerlink" title="3.2 Memory and storage"></a>3.2 Memory and storage</h3><p>the difference between main memory and hard disk drives： volatile nonvolatile</p><p>also the read and write way is different.</p><h3 id="3-3-Address-spaces"><a href="#3-3-Address-spaces" class="headerlink" title="3.3 Address spaces"></a>3.3 Address spaces</h3><p>In general, a process cannot access data belonging to another process, because there is no virtual address it can generate that maps to physical memory allocated to another process.</p><h3 id="3-4-Memory-segments"><a href="#3-4-Memory-segments" class="headerlink" title="3.4 Memory segments"></a>3.4 Memory segments</h3><p>The data of a running process is organized into five segments:</p><ul><li>The code segment contains the program text; that is, the machine language instructions that make up the program.</li><li>The static segment contains immutable values, like string literals. For example, if your program contains the string “Hello, World”, those characters will be stored in the static segment.</li><li>The global segment contains global variables and local variables that are declared static.</li><li>The heap segment contains chunks of memory allocated at run time, most often by calling the C library function malloc.</li><li>The stack segment contains the call stack, which is a sequence of stack frames.</li></ul><p>The arrangement of these segments is determined partly by the compiler and partly by the operating system.</p><h3 id="3-5-Static-local-variables"><a href="#3-5-Static-local-variables" class="headerlink" title="3.5 Static local variables"></a>3.5 Static local variables</h3><ol><li>Local variables on the stack</li><li>allocated in the global segment</li></ol><h3 id="3-6-Address-translation"><a href="#3-6-Address-translation" class="headerlink" title="3.6 Address translation"></a>3.6 Address translation</h3><p>VA——&gt;page number and the offset (MMU)——&gt;looks up the page number in TLB——&gt;PA</p><p>The <strong>TLB</strong> contains cached copies of data from the page table (which is stored in kernel memory). The page table contains the mapping from virtual page numbers to physical page numbers.</p><p>Since each process has its own page table, the TLB has to make sure it only uses entries from the page table of the process that’s running.</p><p>But the fundamental idea is that page tables are sparse, so we have to choose a good implementation for sparse arrays.</p><ul><li>One option is a multilevel page table, which is what many operating systems,<br>including Linux, use.</li><li>Another option is an associative table, where each entry includes both the virtual page number and the physical page number.</li></ul><p>the operating system can interrupt a running process, save its state, and then run another process. This mechanism is called a context switch. Since each process has its own page table, the operating system has to work with the MMU to make sure each process gets the right page table.</p><ul><li>In older machines, the page table information in the MMU had to be replaced during every context switch, which was expensive.</li><li>In newer systems, each page table entry in the MMU includes the process ID, so page tables from multiple processes can be in the MMU at the same time.</li></ul><h2 id="chapter-4-Files-and-file-system"><a href="#chapter-4-Files-and-file-system" class="headerlink" title="chapter 4 Files and file system"></a>chapter 4 Files and file system</h2><p>Data stored on a hard disk drive (HDD) or solid state drive (SSD) is “persistent;”</p><ul><li><p>Hard disk drives are complicated. Data is stored in blocks, which are laid out in sectors, which make up tracks, which are arranged in concentric circles on platters.</p></li><li><p>Solid state drives are simpler in one sense, because blocks are numbered sequentially, but they raise a different complication: each block can be written a limited number of times before it becomes unreliable.</p></li></ul><p>The operating system translates byte-based file operations in the C library into block-based operations on storage devices.</p><ul><li>The process for writing a file. creates a data structure that represents the le being read. the next character is not in memory, the operating system issues an I/O request to get the next block.</li><li>The process for reading a file. If the file already exists, the operating system has to load the first block into memory. Otherwise it allocates a new block in memory and requests a new block on disk. In general, data written to a le is buffered”, which means it is stored in memory and only written to disk when there is at least one block to write.</li></ul><p>To summarize, the C library provides the abstraction of a file system that maps from file names to streams of bytes. This abstraction is built on top of storage devices that are actually organized in blocks.</p><h3 id="4-1-Disk-performance"><a href="#4-1-Disk-performance" class="headerlink" title="4.1 Disk performance"></a>4.1 Disk performance</h3><p>explain quantitatively why why the operating system generally switches to another process while it is waiting for data from disk.</p><p>several features Operating systems and hardware provides to fill in” this gap in performance between main memory and persistent storage</p><h3 id="4-2-Disk-metadata"><a href="#4-2-Disk-metadata" class="headerlink" title="4.2 Disk metadata"></a>4.2 Disk metadata</h3><p>most operating systems don’t require contiguous allocation. They are free to place a block anywhere on disk, and they use various data structures to keep track of them.</p><p>In many UNIX file systems, that data structure is called an “inode,” which stands for “index node”. More generally, information about files, including the location of their blocks, is called “metadata”.</p><p>A UNIX inode contains information about a file, including the user ID of the le owner; permission flags indicating who is allowed to read, write, or execute it; and timestamps that indicate when it was last modified and accessed. In addition, it contains block numbers for the<br>first 12 blocks that make up the file.</p><p>That’s why the inode also contains a pointer to an “indirection block”, which contains nothing but pointers (often 1024) to other blocks.</p><p>the inode also contains a pointer to a “double indirection block”, which contains pointers to indirection blocks.</p><p>As an alternative to indirection blocks, some files systems, like FAT, use a File Allocation Table that contains one entry for each block, called a “cluster” in this context. A root directory contains a pointer to the first cluster in each file. The FAT entry for each cluster points to the next cluster in the file, similar to a linked list.</p><h3 id="4-3-Block-allocation"><a href="#4-3-Block-allocation" class="headerlink" title="4.3 Block allocation"></a>4.3 Block allocation</h3><p>The goals of the block allocation system are: Speed, Minimal space overhead, Minimal fragmentation, Maximum contiguity.</p><p>A le system that is well tuned for one workload might not perform as well for another.</p><p>most operating systems support several kinds of file systems.</p><p>The linux file system immigration history: ext2 ——&gt;ext3 (speed and contiguity) ——&gt;ext4 (large files) ——&gt; ?? B-tree le system</p><h3 id="4-4-Everything-is-a-file"><a href="#4-4-Everything-is-a-file" class="headerlink" title="4.4 Everything is a file"></a>4.4 Everything is a file</h3><p>The essence: The file abstraction is really a “stream of bytes” abstraction.</p><p>For example, the Unix pipe and socket used in Network communication.</p><p>The benefits: </p><ul><li>Reusing the le abstraction makes life easier for programmers</li><li>makes programs more versatile</li></ul>]]></content>
    
    
    <categories>
      
      <category>Operating System</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2020/08/08/20200808-effective%20java28%2029/"/>
    <url>/2020/08/08/20200808-effective%20java28%2029/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2020/08/08/20200808-java%20%E5%BC%82%E5%B8%B8/"/>
    <url>/2020/08/08/20200808-java%20%E5%BC%82%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<p>java异常体系：</p><p><a href="https://blog.csdn.net/u011011282/article/details/79569207">异常体系</a></p><p><a href="https://blog.csdn.net/Junlixxu/article/details/6096266?utm_medium=distribute.pc_relevant_right.none-task-blog-searchFromBaidu-8.channel_param_right&depth_1-utm_source=distribute.pc_relevant_right.none-task-blog-searchFromBaidu-8.channel_param_right">异常体系2</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>静态成员类优于非静态成员类</title>
    <link href="/2020/08/08/20200808-effective%20java24/"/>
    <url>/2020/08/08/20200808-effective%20java24/</url>
    
    <content type="html"><![CDATA[<p>1之前使用过Map的Entry内部类，也接触过内部类，借此机会整理下笔记。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ul><li><p>嵌套类和内部类的定义，区别：</p></li><li><p>嵌套类的种类，及各自使用案例：</p></li></ul><h2 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h2><p>定义：类A定义在类B中，则A为B的嵌套类，B为A的外围类。嵌套类分为：</p><ul><li>静态成员类</li><li>非静态成员类</li><li>匿名类</li><li>局部类</li></ul><h3 id="静态成员类"><a href="#静态成员类" class="headerlink" title="静态成员类"></a>静态成员类</h3><p>定义：用static修饰。嵌套类实例独立存在于外围类实例。</p><p>用法：与外部类一起使用。eg, Caculator.Operation.Plus(), Minus()</p><p>私有静态成员类的一个常见用法：Map实现的内部有Entry对象。get，set方法可直接作用于Entry而不是Map。</p><h3 id="非静态成员类"><a href="#非静态成员类" class="headerlink" title="非静态成员类"></a>非静态成员类</h3><p>定义：无static修饰。每个类实例都和外围类实例相关联，类方法可以调用外围实例的方法和引用。类实例包含一个额外的对外围对象的引用，消耗时间和空间。并且这个引用可能带来垃圾回收的问题。</p><p>用法：定义一个adapter。eg, Map接口使用非静态成员类来实现集合视图, Set, List接口用其实现迭代器。</p><h3 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h3><p>如果成员类无需访问外围实例，最好加static。</p><ul><li><p>静态内部类用static修饰</p></li><li><p>static修饰全局变量：<br>static修饰的全局变量只能被该包含该定义的文件访问。</p></li><li><p>static修饰函数：<br>static修饰函数使得函数只能在包含该函数定义的文件中被调用。</p></li><li><p>C++中的static：<br>如果在C++中对类中的某个函数用static进行修饰，则表示该函数属于一个类而不是属于此类的任何特定对象；如果对类中的某个变量进行static修饰，表示该变量为类以及其所有的对象所有。它们在存储空间中都只存在一个副本。可以通过类和对象去调用。    </p></li></ul><h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><ul><li><p>访问寄存器要比访问内存要块，因此CPU会优先访问该数据在寄存器中的存储结果，但是内存中的数据可能已经发生了改变，而寄存器中还保留着原来的结果。为了避免这种情况的发生将该变量声明为<code>volatile</code>，告诉CPU每次都从内存去读取数据。</p></li><li><p>易变性</p></li><li><p>”不可优化”特性</p></li><li><p>”顺序性”</p></li></ul><h2 id="const-关键字"><a href="#const-关键字" class="headerlink" title="const 关键字"></a>const 关键字</h2><p>作用：</p><ul><li>const修饰全局变量；</li><li>const修饰局部变量；</li><li>const修饰指针，const int *；</li><li>const修饰指针指向的对象, int * const；</li><li>const修饰引用做形参；</li><li>const修饰成员变量，必须在构造函数列表中初始化；</li><li>const修饰成员函数，说明该函数不应该修改非静态成员，但是这并不是十分可靠的，指针所指的非成员对象值可能会被改变。</li></ul><h2 id="new与malloc区别"><a href="#new与malloc区别" class="headerlink" title="new与malloc区别"></a><a href="https://blog.csdn.net/shanghairuoxiao/article/details/70337890">new与malloc区别</a></h2><ul><li>malloc和free是库函数，而new和delete是C++操作符，且可以重载；</li></ul><ul><li><p>malloc需要指定大小，new自己计算需要的空间大小；</p></li><li><p>new在动态分配内存的时候可以初始化对象，调用其构造函数，delete在释放内存时调用对象的析构函数；</p></li><li><p>对于数据C++定义<code>new[]</code>专门进行动态数组分配，用<code>delete[]</code>进行销毁。<code>new[]</code>会一次分配内存，然后多次调用构造函数；<code>delete[]</code>会先多次调用析构函数，然后一次性释放；</p></li><li><p>malloc能够使用realloc函数直观地重新分配内存。</p></li></ul><h2 id="C-多态性与虚函数表"><a href="#C-多态性与虚函数表" class="headerlink" title="C++多态性与虚函数表"></a><a href="https://blog.csdn.net/hackbuteer1/article/details/7475622">C++多态性与虚函数表</a></h2><ul><li><p>“一个接口，多种方法”，程序在运行时才决定调用的函数。</p></li><li><p>三条件：继承、虚函数重写、父类指针指向子类对象。</p></li><li><p>多态与非多态的实质区别就是函数地址是早绑定还是晚绑定。如果函数的调用，在编译器编译期间就可以确定函数的调用地址，并生产代码，是静态的，就是说地址是早绑定的。而如果函数调用的地址不能在编译器期间确定，需要在运行时才确定，这就属于晚绑定。</p></li><li><p>C++中虚函数使用虚函数表和虚函数表指针实现，虚函数表是一个类的虚函数的地址表，用于索引类本身以及父类的虚函数的地址，假如子类重写了父类的虚函数，则对应在虚函数表中会把对应的虚函数替换为子类的同名函数的地址；虚函数表指针存在于每个对象中（通常会放在对象的开始地址处），它指向对象所在类的虚函数表的地址；在多重继承环境下，有几个基类就有几个虚函数指针，分别指向对应不同基类的虚函数表。虚函数表是作为read only的data被放在.rodata段。</p></li></ul><h3 id="虚函数表是针对类的还是针对对象的？同一个类的两个对象的虚函数表是怎么维护的？"><a href="#虚函数表是针对类的还是针对对象的？同一个类的两个对象的虚函数表是怎么维护的？" class="headerlink" title="虚函数表是针对类的还是针对对象的？同一个类的两个对象的虚函数表是怎么维护的？"></a>虚函数表是针对类的还是针对对象的？同一个类的两个对象的虚函数表是怎么维护的？</h3><p>编译器为每一个类维护一个虚函数表，每个对象的首地址保存着该虚函数表的指针，同一个类的不同对象实际上指向同一张虚函数表。</p><h3 id="析构函数要定义成虚函数？"><a href="#析构函数要定义成虚函数？" class="headerlink" title="析构函数要定义成虚函数？"></a>析构函数要定义成虚函数？</h3><p>析构函数没有定义为析构函数，则会调用基类的析构函数，显然只能销毁部分数据。如果要调用对象的析构函数，就需要将该对象的析构函数定义为虚函数，销毁时通过虚函数表找到对应的析构函数。</p><h3 id="析构函数能抛出异常吗？"><a href="#析构函数能抛出异常吗？" class="headerlink" title="析构函数能抛出异常吗？"></a>析构函数能抛出异常吗？</h3><p>  不能。C++标准指明析构函数不能、也不应该抛出异常。</p><ol><li>如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题。</li><li>通常异常发生时，c++的机制会调用已经构造对象的析构函数来释放资源，此时若析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃的问题。</li></ol><h3 id="构造函数为什么不能声明为虚函数？"><a href="#构造函数为什么不能声明为虚函数？" class="headerlink" title="构造函数为什么不能声明为虚函数？"></a>构造函数为什么不能声明为虚函数？</h3><p>虚函数的调用需要虚函数表指针，而该指针存放在对象的内容空间中；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表指针用来调用虚函数表中的虚构造函数了。</p><h3 id="构造函数和析构函数中可以调用虚函数吗？"><a href="#构造函数和析构函数中可以调用虚函数吗？" class="headerlink" title="构造函数和析构函数中可以调用虚函数吗？"></a>构造函数和析构函数中可以调用虚函数吗？</h3><p>可以，但是没有意义，起不到动态绑定的效果。父类构造函数中调用的仍然是父类版本的函数，子类中调用的仍然是子类版本的函数。</p><h3 id="内联函数为什么不能声明为虚函数？"><a href="#内联函数为什么不能声明为虚函数？" class="headerlink" title="内联函数为什么不能声明为虚函数？"></a>内联函数为什么不能声明为虚函数？</h3><p>内联函数需要在编译阶段展开，编译时就已经确定了，而虚函数是运行时动态绑定的，编译时无法展开，因此是矛盾的。</p><h3 id="静态成员函数为什么不能声明为虚函数？"><a href="#静态成员函数为什么不能声明为虚函数？" class="headerlink" title="静态成员函数为什么不能声明为虚函数？"></a>静态成员函数为什么不能声明为虚函数？</h3><p>静态成员函数是以类为单位的函数，与具体对象无关，虚函数是与对象动态绑定的，因此是矛盾的。</p><h2 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h2><ul><li>指针保存的是所指对象的地址，引用是所指对象的别名，指针需要通过解引用间接访问，而引用是直接访问；</li><li>指针可以改变地址，从而改变所指的对象，而引用必须从一而终；</li><li>引用在定义的时候必须初始化，而指针则不需要；</li><li>指针有指向常量的指针和指针常量，而引用没有常量引用；</li><li>指针更灵活，而引用则更为安全。</li></ul><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><h3 id="智能指针实现原理？"><a href="#智能指针实现原理？" class="headerlink" title="智能指针实现原理？"></a>智能指针实现原理？</h3><p>每次创建类的新对象时，初始化指针并将引用计数置为1；当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数；对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数；调用析构函数时，构造函数减少引用计数（如果引用计数减至0，则删除基础对象）。</p><h3 id="unique-ptr可以拷贝构造吗？可以拷贝赋值吗？"><a href="#unique-ptr可以拷贝构造吗？可以拷贝赋值吗？" class="headerlink" title="unique_ptr可以拷贝构造吗？可以拷贝赋值吗？"></a>unique_ptr可以拷贝构造吗？可以拷贝赋值吗？</h3><p>不可以。（C++ Primer P418）但是可以利用成员函数 reset 和 release 重新绑定。</p><h3 id="share-ptr的循环引用？"><a href="#share-ptr的循环引用？" class="headerlink" title="share_ptr的循环引用？"></a>share_ptr的循环引用？</h3><pre><code class="hljs C++"><span class="hljs-comment">//share_ptr可能出现循环引用，从而导致内存泄露</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:    share_ptr&lt;B&gt; p;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:    share_ptr&lt;A&gt; p;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)    &#123;        <span class="hljs-function">share_prt&lt;A&gt; <span class="hljs-title">pa</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A())</span></span>; <span class="hljs-comment">//pa的引用计数初始化为1</span>        <span class="hljs-function">share_prt&lt;B&gt; <span class="hljs-title">pb</span><span class="hljs-params">(<span class="hljs-keyword">new</span> B())</span></span>; <span class="hljs-comment">//pb的引用计数初始化为1</span>        pa-&gt;p = pb; <span class="hljs-comment">//pb的引用计数变为2</span>        pb-&gt;p = pa; <span class="hljs-comment">//pa的引用计数变为2</span>    &#125;    <span class="hljs-comment">//假设pa先离开，引用计数减一变为1，不为0因此不会调用class A的析构函数，因此其成员p也不会被析构，pb的引用计数仍然为2；</span>    <span class="hljs-comment">//同理pb离开的时候，引用计数也不能减到0</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">** weak_ptr是一种弱引用指针，其存在不会影响引用计数，从而解决循环引用的问题</span><span class="hljs-comment">*/</span></code></pre><h2 id="C-类型转换"><a href="#C-类型转换" class="headerlink" title="C++类型转换"></a>C++类型转换</h2><ul><li>const_cast用于将const变量转为非const</li><li>static_cast用的最多，对于各种隐式转换，非const转const，void*转指针等, static_cast能用于多态想上转化，如果向下转能成功但是不安全，结果未知；</li><li>dynamic_cast用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。要深入了解内部转换的原理。</li><li>reinterpret_cast用于重新解释，可能会出问题，尽量少用；<br>为什么不使用C的强制转换？C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。</li></ul><h2 id="内存对齐和对象所占内存计算"><a href="#内存对齐和对象所占内存计算" class="headerlink" title="内存对齐和对象所占内存计算"></a>内存对齐和对象所占内存计算</h2><p>这个看看《深度探索C++对象模型》的第三章P84开始。（虽然我看了就忘了）</p><ul><li><p>一个空类对象的size是1，因为要保证每个对象占用不同的地址。</p></li><li><p>一个对象的大小，取决于其非静态数据成员所占空间和：</p><ol><li>若是虚继承，则有指向父类的指针，若虚继承的子类作为父类，则其派生出的子类也会有该指针；</li><li>存在虚函数则有vptr指针，若虚函数来字不同的父类，则有多个不同得到vptr指针。</li><li>静态数据成员在全局区，不占用对象的内存；</li><li>还要考虑内存对齐，<a href="https://blog.csdn.net/weixin_41066529/article/details/89496593">内存对齐三原则</a>。</li></ol></li></ul><h2 id="内联函数有什么优点？内联函数与宏定义的区别？"><a href="#内联函数有什么优点？内联函数与宏定义的区别？" class="headerlink" title="内联函数有什么优点？内联函数与宏定义的区别？"></a>内联函数有什么优点？内联函数与宏定义的区别？</h2><ul><li>宏定义在预处理的时候就会进行宏替换；</li><li>内联函数在编译阶段，在调用内联函数的地方进行替换，减少了函数的调用过程，但是使得编译文件变大。因此，内联函数适合简单函数，对于复杂函数，即使定义了内联编译器可能也不会按照内联的方式进行编译。</li><li>内联函数相比宏定义更安全，内联函数可以检查参数，而宏定义只是简单的文本替换。因此推荐使用内联函数，而不是宏定义。</li><li>使用宏定义函数要特别注意给所有单元都加上括号，#define MUL(a, b) a * b，这很危险，正确写法：#define MUL(a, b) ((a) * (b))。</li></ul><h2 id="C-内存管理"><a href="#C-内存管理" class="headerlink" title="C++内存管理"></a>C++内存管理</h2><ul><li>栈区（stack）：由编译器自动分配和释放，用来存放函数的参数、局部变量等。其操作方式类似于数据结构中的栈。</li><li>堆区（heap）：一般由程序员分配和释放（通过malloc/free、new/delete），若程序员没有释放，则程序结束时由操作系统回收。它与数据结构中的堆是两回事，分配方式类似于链表。</li><li>全局/静态区：全局变量和静态变量的存储是放在一块的，初始化的全局变量和初始化的静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域，程序结束后由操作系统回收。</li><li>文字常量区：存放常量值，如常量字符串等，不允许修改，程序结束后由操作系统回收。</li><li>程序代码区：存放函数体的二进制代码。</li></ul><h2 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h2><p>  C++程序默认的内存管理（new，delete，malloc，free）会频繁地在堆上分配和释放内存，导致性能的损失，产生大量的内存碎片，降低内存的利用率。</p><p>  分为一级分配器和二级分配器进行内存分配。一级分配器就是采用malloc分配内存，二级分配器采用内存池。基本思路是设计一个 <code>free_list[16]</code> 数组，负责管理从 8 bytes 到 128 bytes 不同大小的内存块（ chunk ），每一个内存块都由连续的固定大小（ fixed size block ）的很多 chunk 组成，并用指针链表串接起来。</p><h2 id="STL里set和map是基于什么实现的。红黑树的特点？"><a href="#STL里set和map是基于什么实现的。红黑树的特点？" class="headerlink" title="STL里set和map是基于什么实现的。红黑树的特点？"></a>STL里set和map是基于什么实现的。红黑树的特点？</h2><p><a href="https://www.jianshu.com/p/e136ec79235c">红黑树</a>。</p><ul><li>左旋：以某个结点作为支点(旋转结点)，其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子结点，左子结点保持不变。</li><li>右旋：以某个结点作为支点(旋转结点)，其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变。</li><li>变色：结点的颜色由红变黑或由黑变红。</li></ul><h2 id="定位内存泄漏"><a href="#定位内存泄漏" class="headerlink" title="定位内存泄漏"></a>定位内存泄漏</h2><ul><li>内存泄漏：指由于疏忽或错误造成程序未能释放已经不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费。</li></ul><p>检测方法：</p><ul><li><p>在windows平台下通过CRT中的库函数进行检测；</p><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _CRTDBG_MAP_ALLOC</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;crtdbg.h&gt;</span></span><span class="hljs-comment">/*...*/</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">/*...*/</span>_CrtDumpMemoryLeaks();<span class="hljs-comment">//调试时在输出窗口显示内存泄漏信息</span>&#125;</code></pre></li><li><p>在可能泄漏的调用前后生成块的快照，比较前后的状态，定位泄漏的位置；</p><p>&lt;!–hexoPostRenderEscape:<pre><code class="hljs C">_CrtMemState s1, s2, s3;<span class="hljs-comment">//结构体</span><br><span class="hljs-comment">/<em>...</em>/</span><br>_CrtMemCheckpoint(&amp;s1);<br><span class="hljs-comment">// memory allocations take place here</span><br>_CrtMemCheckpoint( &amp;s2 );</p></li></ul><p><span class="hljs-keyword">if</span>( _CrtMemDifference( &amp;s3, &amp;s1, &amp;s2) )<br>  _CrtMemDumpStatistics( &amp;s3 );</code></pre>:hexoPostRenderEscape–&gt;</p><ul><li>Linux下通过工具valgrind检测。</li></ul><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><h3 id="STL六大组件："><a href="#STL六大组件：" class="headerlink" title="STL六大组件："></a>STL六大组件：</h3><p>  容器、算法、迭代器、仿函数、配接器、配置器。</p><h2 id="用C-设计一个不能被继承的类？"><a href="#用C-设计一个不能被继承的类？" class="headerlink" title="用C++设计一个不能被继承的类？"></a>用C++设计一个不能被继承的类？</h2><p>  构造函数或析构函数为私有函数，所以该类是无法被继承的。</p><p>  此时要想获得该类的实例，则需要为这个类定义静态函数的帮助。</p>  <pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">sealedClass</span></span><span class="hljs-class">&#123;</span>  <span class="hljs-comment">//通过定义公有的静态函数来创建和释放类的实例</span>  <span class="hljs-keyword">public</span>: <span class="hljs-function"><span class="hljs-keyword">static</span> sealedClass* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span><span class="hljs-function"> </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> sealedClass(); &#125; <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteInstance</span><span class="hljs-params">(sealedClass* pInstance)</span></span><span class="hljs-function"> </span>&#123;  <span class="hljs-keyword">delete</span> pInstance; &#125;  <span class="hljs-comment">//通过将类的构造函数和析构函数设为私有成员，从而使该类不能被其它类继承</span>  <span class="hljs-keyword">private</span>: sealedClass()  &#123;      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;base class construct function!&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;  &#125; ~sealedClass() &#123;&#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123; sealedClass* pInstance; pInstance = sealedClass::getInstance(); pInstance-&gt;deleteInstance(pInstance);&#125;</code></pre><h2 id="如何定义一个只能在堆上定义对象的类-栈上呢"><a href="#如何定义一个只能在堆上定义对象的类-栈上呢" class="headerlink" title="如何定义一个只能在堆上定义对象的类?栈上呢?"></a>如何定义一个只能在堆上定义对象的类?栈上呢?</h2><ul><li>只能在堆内存上实例化的类：将析构函数定义为private，在栈上不能自动调用析构函数，只能手动调用；也可以将构造函数定义为private。</li><li>只能在栈内存上实例化的类：将函数operator new和operator delete定义为private，这样使用new操作符创建对象时候，无法调用operator new，delete销毁对象也无法调用operator delete。</li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>java specification</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello world</title>
    <link href="/2020/08/07/hello-world/"/>
    <url>/2020/08/07/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span></code></pre><p><img src="https://img-blog.csdnimg.cn/20200807151328607.png" alt="java多线程思维导图"></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>面经知识点总结</title>
    <link href="/2020/08/07/20200629_Cpp/"/>
    <url>/2020/08/07/20200629_Cpp/</url>
    
    <content type="html"><![CDATA[<p>最近看了不少面经，发现自己很多基础知识点掌握的不是很好，这里总结一下。</p><h2 id="extern关键字作用"><a href="#extern关键字作用" class="headerlink" title="extern关键字作用"></a><a href="https://www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777431.html">extern关键字作用</a></h2><p>主要两个作用：</p><ul><li><p>修饰变量或函数：<br>extern 变量与 extern 函数声明，声明该变量或函数在别的源文件中定义。</p></li><li><p>链接指定：<br>与”C”一起连用时，如: extern “C” void fun(int a, int b);则告诉编译器在编译fun这个函数名时按着C的规则去翻译相应的函数名</p></li></ul><h2 id="static关键字作用"><a href="#static关键字作用" class="headerlink" title="static关键字作用"></a><a href="https://blog.csdn.net/shanghairuoxiao/article/details/72904292">static关键字作用</a></h2><p>控制变量的存储方式和可见性。 </p><ul><li><p>static修饰局部变量：<br>static修饰局部变量时，使得被修饰的变量成为静态变量，存储在静态区。存储在静态区的数据生命周期与程序相同，在main函数之前初始化，在程序退出时销毁。（无论是局部静态还是全局静态）</p></li><li><p>static修饰全局变量：<br>static修饰的全局变量只能被该包含该定义的文件访问。</p></li><li><p>static修饰函数：<br>static修饰函数使得函数只能在包含该函数定义的文件中被调用。</p></li><li><p>C++中的static：<br>如果在C++中对类中的某个函数用static进行修饰，则表示该函数属于一个类而不是属于此类的任何特定对象；如果对类中的某个变量进行static修饰，表示该变量为类以及其所有的对象所有。它们在存储空间中都只存在一个副本。可以通过类和对象去调用。    </p></li></ul><h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><ul><li><p>访问寄存器要比访问内存要块，因此CPU会优先访问该数据在寄存器中的存储结果，但是内存中的数据可能已经发生了改变，而寄存器中还保留着原来的结果。为了避免这种情况的发生将该变量声明为<code>volatile</code>，告诉CPU每次都从内存去读取数据。</p></li><li><p>易变性</p></li><li><p>”不可优化”特性</p></li><li><p>”顺序性”</p></li></ul><h2 id="const-关键字"><a href="#const-关键字" class="headerlink" title="const 关键字"></a>const 关键字</h2><p>作用：</p><ul><li>const修饰全局变量；</li><li>const修饰局部变量；</li><li>const修饰指针，const int *；</li><li>const修饰指针指向的对象, int * const；</li><li>const修饰引用做形参；</li><li>const修饰成员变量，必须在构造函数列表中初始化；</li><li>const修饰成员函数，说明该函数不应该修改非静态成员，但是这并不是十分可靠的，指针所指的非成员对象值可能会被改变。</li></ul><h2 id="new与malloc区别"><a href="#new与malloc区别" class="headerlink" title="new与malloc区别"></a><a href="https://blog.csdn.net/shanghairuoxiao/article/details/70337890">new与malloc区别</a></h2><ul><li>malloc和free是库函数，而new和delete是C++操作符，且可以重载；</li></ul><ul><li><p>malloc需要指定大小，new自己计算需要的空间大小；</p></li><li><p>new在动态分配内存的时候可以初始化对象，调用其构造函数，delete在释放内存时调用对象的析构函数；</p></li><li><p>对于数据C++定义<code>new[]</code>专门进行动态数组分配，用<code>delete[]</code>进行销毁。<code>new[]</code>会一次分配内存，然后多次调用构造函数；<code>delete[]</code>会先多次调用析构函数，然后一次性释放；</p></li><li><p>malloc能够使用realloc函数直观地重新分配内存。</p></li></ul><h2 id="C-多态性与虚函数表"><a href="#C-多态性与虚函数表" class="headerlink" title="C++多态性与虚函数表"></a><a href="https://blog.csdn.net/hackbuteer1/article/details/7475622">C++多态性与虚函数表</a></h2><ul><li><p>“一个接口，多种方法”，程序在运行时才决定调用的函数。</p></li><li><p>三条件：继承、虚函数重写、父类指针指向子类对象。</p></li><li><p>多态与非多态的实质区别就是函数地址是早绑定还是晚绑定。如果函数的调用，在编译器编译期间就可以确定函数的调用地址，并生产代码，是静态的，就是说地址是早绑定的。而如果函数调用的地址不能在编译器期间确定，需要在运行时才确定，这就属于晚绑定。</p></li><li><p>C++中虚函数使用虚函数表和虚函数表指针实现，虚函数表是一个类的虚函数的地址表，用于索引类本身以及父类的虚函数的地址，假如子类重写了父类的虚函数，则对应在虚函数表中会把对应的虚函数替换为子类的同名函数的地址；虚函数表指针存在于每个对象中（通常会放在对象的开始地址处），它指向对象所在类的虚函数表的地址；在多重继承环境下，有几个基类就有几个虚函数指针，分别指向对应不同基类的虚函数表。虚函数表是作为read only的data被放在.rodata段。</p></li></ul><h3 id="虚函数表是针对类的还是针对对象的？同一个类的两个对象的虚函数表是怎么维护的？"><a href="#虚函数表是针对类的还是针对对象的？同一个类的两个对象的虚函数表是怎么维护的？" class="headerlink" title="虚函数表是针对类的还是针对对象的？同一个类的两个对象的虚函数表是怎么维护的？"></a>虚函数表是针对类的还是针对对象的？同一个类的两个对象的虚函数表是怎么维护的？</h3><p>编译器为每一个类维护一个虚函数表，每个对象的首地址保存着该虚函数表的指针，同一个类的不同对象实际上指向同一张虚函数表。</p><h3 id="析构函数要定义成虚函数？"><a href="#析构函数要定义成虚函数？" class="headerlink" title="析构函数要定义成虚函数？"></a>析构函数要定义成虚函数？</h3><p>析构函数没有定义为析构函数，则会调用基类的析构函数，显然只能销毁部分数据。如果要调用对象的析构函数，就需要将该对象的析构函数定义为虚函数，销毁时通过虚函数表找到对应的析构函数。</p><h3 id="析构函数能抛出异常吗？"><a href="#析构函数能抛出异常吗？" class="headerlink" title="析构函数能抛出异常吗？"></a>析构函数能抛出异常吗？</h3><p>  不能。C++标准指明析构函数不能、也不应该抛出异常。</p><ol><li>如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题。</li><li>通常异常发生时，c++的机制会调用已经构造对象的析构函数来释放资源，此时若析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃的问题。</li></ol><h3 id="构造函数为什么不能声明为虚函数？"><a href="#构造函数为什么不能声明为虚函数？" class="headerlink" title="构造函数为什么不能声明为虚函数？"></a>构造函数为什么不能声明为虚函数？</h3><p>虚函数的调用需要虚函数表指针，而该指针存放在对象的内容空间中；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表指针用来调用虚函数表中的虚构造函数了。</p><h3 id="构造函数和析构函数中可以调用虚函数吗？"><a href="#构造函数和析构函数中可以调用虚函数吗？" class="headerlink" title="构造函数和析构函数中可以调用虚函数吗？"></a>构造函数和析构函数中可以调用虚函数吗？</h3><p>可以，但是没有意义，起不到动态绑定的效果。父类构造函数中调用的仍然是父类版本的函数，子类中调用的仍然是子类版本的函数。</p><h3 id="内联函数为什么不能声明为虚函数？"><a href="#内联函数为什么不能声明为虚函数？" class="headerlink" title="内联函数为什么不能声明为虚函数？"></a>内联函数为什么不能声明为虚函数？</h3><p>内联函数需要在编译阶段展开，编译时就已经确定了，而虚函数是运行时动态绑定的，编译时无法展开，因此是矛盾的。</p><h3 id="静态成员函数为什么不能声明为虚函数？"><a href="#静态成员函数为什么不能声明为虚函数？" class="headerlink" title="静态成员函数为什么不能声明为虚函数？"></a>静态成员函数为什么不能声明为虚函数？</h3><p>静态成员函数是以类为单位的函数，与具体对象无关，虚函数是与对象动态绑定的，因此是矛盾的。</p><h2 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h2><ul><li>指针保存的是所指对象的地址，引用是所指对象的别名，指针需要通过解引用间接访问，而引用是直接访问；</li><li>指针可以改变地址，从而改变所指的对象，而引用必须从一而终；</li><li>引用在定义的时候必须初始化，而指针则不需要；</li><li>指针有指向常量的指针和指针常量，而引用没有常量引用；</li><li>指针更灵活，而引用则更为安全。</li></ul><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><h3 id="智能指针实现原理？"><a href="#智能指针实现原理？" class="headerlink" title="智能指针实现原理？"></a>智能指针实现原理？</h3><p>每次创建类的新对象时，初始化指针并将引用计数置为1；当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数；对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数；调用析构函数时，构造函数减少引用计数（如果引用计数减至0，则删除基础对象）。</p><h3 id="unique-ptr可以拷贝构造吗？可以拷贝赋值吗？"><a href="#unique-ptr可以拷贝构造吗？可以拷贝赋值吗？" class="headerlink" title="unique_ptr可以拷贝构造吗？可以拷贝赋值吗？"></a>unique_ptr可以拷贝构造吗？可以拷贝赋值吗？</h3><p>不可以。（C++ Primer P418）但是可以利用成员函数 reset 和 release 重新绑定。</p><h3 id="share-ptr的循环引用？"><a href="#share-ptr的循环引用？" class="headerlink" title="share_ptr的循环引用？"></a>share_ptr的循环引用？</h3><pre><code class="hljs C++"><span class="hljs-comment">//share_ptr可能出现循环引用，从而导致内存泄露</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:    share_ptr&lt;B&gt; p;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:    share_ptr&lt;A&gt; p;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)    &#123;        <span class="hljs-function">share_prt&lt;A&gt; <span class="hljs-title">pa</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A())</span></span>; <span class="hljs-comment">//pa的引用计数初始化为1</span>        <span class="hljs-function">share_prt&lt;B&gt; <span class="hljs-title">pb</span><span class="hljs-params">(<span class="hljs-keyword">new</span> B())</span></span>; <span class="hljs-comment">//pb的引用计数初始化为1</span>        pa-&gt;p = pb; <span class="hljs-comment">//pb的引用计数变为2</span>        pb-&gt;p = pa; <span class="hljs-comment">//pa的引用计数变为2</span>    &#125;    <span class="hljs-comment">//假设pa先离开，引用计数减一变为1，不为0因此不会调用class A的析构函数，因此其成员p也不会被析构，pb的引用计数仍然为2；</span>    <span class="hljs-comment">//同理pb离开的时候，引用计数也不能减到0</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">** weak_ptr是一种弱引用指针，其存在不会影响引用计数，从而解决循环引用的问题</span><span class="hljs-comment">*/</span></code></pre><h2 id="C-类型转换"><a href="#C-类型转换" class="headerlink" title="C++类型转换"></a>C++类型转换</h2><ul><li>const_cast用于将const变量转为非const</li><li>static_cast用的最多，对于各种隐式转换，非const转const，void*转指针等, static_cast能用于多态想上转化，如果向下转能成功但是不安全，结果未知；</li><li>dynamic_cast用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。要深入了解内部转换的原理。</li><li>reinterpret_cast用于重新解释，可能会出问题，尽量少用；<br>为什么不使用C的强制转换？C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。</li></ul><h2 id="内存对齐和对象所占内存计算"><a href="#内存对齐和对象所占内存计算" class="headerlink" title="内存对齐和对象所占内存计算"></a>内存对齐和对象所占内存计算</h2><p>这个看看《深度探索C++对象模型》的第三章P84开始。（虽然我看了就忘了）</p><ul><li><p>一个空类对象的size是1，因为要保证每个对象占用不同的地址。</p></li><li><p>一个对象的大小，取决于其非静态数据成员所占空间和：</p><ol><li>若是虚继承，则有指向父类的指针，若虚继承的子类作为父类，则其派生出的子类也会有该指针；</li><li>存在虚函数则有vptr指针，若虚函数来字不同的父类，则有多个不同得到vptr指针。</li><li>静态数据成员在全局区，不占用对象的内存；</li><li>还要考虑内存对齐，<a href="https://blog.csdn.net/weixin_41066529/article/details/89496593">内存对齐三原则</a>。</li></ol></li></ul><h2 id="内联函数有什么优点？内联函数与宏定义的区别？"><a href="#内联函数有什么优点？内联函数与宏定义的区别？" class="headerlink" title="内联函数有什么优点？内联函数与宏定义的区别？"></a>内联函数有什么优点？内联函数与宏定义的区别？</h2><ul><li>宏定义在预处理的时候就会进行宏替换；</li><li>内联函数在编译阶段，在调用内联函数的地方进行替换，减少了函数的调用过程，但是使得编译文件变大。因此，内联函数适合简单函数，对于复杂函数，即使定义了内联编译器可能也不会按照内联的方式进行编译。</li><li>内联函数相比宏定义更安全，内联函数可以检查参数，而宏定义只是简单的文本替换。因此推荐使用内联函数，而不是宏定义。</li><li>使用宏定义函数要特别注意给所有单元都加上括号，#define MUL(a, b) a * b，这很危险，正确写法：#define MUL(a, b) ((a) * (b))。</li></ul><h2 id="C-内存管理"><a href="#C-内存管理" class="headerlink" title="C++内存管理"></a>C++内存管理</h2><ul><li>栈区（stack）：由编译器自动分配和释放，用来存放函数的参数、局部变量等。其操作方式类似于数据结构中的栈。</li><li>堆区（heap）：一般由程序员分配和释放（通过malloc/free、new/delete），若程序员没有释放，则程序结束时由操作系统回收。它与数据结构中的堆是两回事，分配方式类似于链表。</li><li>全局/静态区：全局变量和静态变量的存储是放在一块的，初始化的全局变量和初始化的静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域，程序结束后由操作系统回收。</li><li>文字常量区：存放常量值，如常量字符串等，不允许修改，程序结束后由操作系统回收。</li><li>程序代码区：存放函数体的二进制代码。</li></ul><h2 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h2><p>  C++程序默认的内存管理（new，delete，malloc，free）会频繁地在堆上分配和释放内存，导致性能的损失，产生大量的内存碎片，降低内存的利用率。</p><p>  分为一级分配器和二级分配器进行内存分配。一级分配器就是采用malloc分配内存，二级分配器采用内存池。基本思路是设计一个 <code>free_list[16]</code> 数组，负责管理从 8 bytes 到 128 bytes 不同大小的内存块（ chunk ），每一个内存块都由连续的固定大小（ fixed size block ）的很多 chunk 组成，并用指针链表串接起来。</p><h2 id="STL里set和map是基于什么实现的。红黑树的特点？"><a href="#STL里set和map是基于什么实现的。红黑树的特点？" class="headerlink" title="STL里set和map是基于什么实现的。红黑树的特点？"></a>STL里set和map是基于什么实现的。红黑树的特点？</h2><p><a href="https://www.jianshu.com/p/e136ec79235c">红黑树</a>。</p><ul><li>左旋：以某个结点作为支点(旋转结点)，其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子结点，左子结点保持不变。</li><li>右旋：以某个结点作为支点(旋转结点)，其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变。</li><li>变色：结点的颜色由红变黑或由黑变红。</li></ul><h2 id="定位内存泄漏"><a href="#定位内存泄漏" class="headerlink" title="定位内存泄漏"></a>定位内存泄漏</h2><ul><li>内存泄漏：指由于疏忽或错误造成程序未能释放已经不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费。</li></ul><p>检测方法：</p><ul><li><p>在windows平台下通过CRT中的库函数进行检测；</p><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _CRTDBG_MAP_ALLOC</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;crtdbg.h&gt;</span></span><span class="hljs-comment">/*...*/</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">/*...*/</span>_CrtDumpMemoryLeaks();<span class="hljs-comment">//调试时在输出窗口显示内存泄漏信息</span>&#125;</code></pre></li><li><p>在可能泄漏的调用前后生成块的快照，比较前后的状态，定位泄漏的位置；</p><p>&lt;!–hexoPostRenderEscape:<pre><code class="hljs C">_CrtMemState s1, s2, s3;<span class="hljs-comment">//结构体</span><br><span class="hljs-comment">/<em>...</em>/</span><br>_CrtMemCheckpoint(&amp;s1);<br><span class="hljs-comment">// memory allocations take place here</span><br>_CrtMemCheckpoint( &amp;s2 );</p></li></ul><p><span class="hljs-keyword">if</span>( _CrtMemDifference( &amp;s3, &amp;s1, &amp;s2) )<br>  _CrtMemDumpStatistics( &amp;s3 );</code></pre>:hexoPostRenderEscape–&gt;</p><ul><li>Linux下通过工具valgrind检测。</li></ul><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><h3 id="STL六大组件："><a href="#STL六大组件：" class="headerlink" title="STL六大组件："></a>STL六大组件：</h3><p>  容器、算法、迭代器、仿函数、配接器、配置器。</p><h2 id="用C-设计一个不能被继承的类？"><a href="#用C-设计一个不能被继承的类？" class="headerlink" title="用C++设计一个不能被继承的类？"></a>用C++设计一个不能被继承的类？</h2><p>  构造函数或析构函数为私有函数，所以该类是无法被继承的。</p><p>  此时要想获得该类的实例，则需要为这个类定义静态函数的帮助。</p>  <pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">sealedClass</span></span><span class="hljs-class">&#123;</span>  <span class="hljs-comment">//通过定义公有的静态函数来创建和释放类的实例</span>  <span class="hljs-keyword">public</span>: <span class="hljs-function"><span class="hljs-keyword">static</span> sealedClass* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span><span class="hljs-function"> </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> sealedClass(); &#125; <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteInstance</span><span class="hljs-params">(sealedClass* pInstance)</span></span><span class="hljs-function"> </span>&#123;  <span class="hljs-keyword">delete</span> pInstance; &#125;  <span class="hljs-comment">//通过将类的构造函数和析构函数设为私有成员，从而使该类不能被其它类继承</span>  <span class="hljs-keyword">private</span>: sealedClass()  &#123;      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;base class construct function!&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;  &#125; ~sealedClass() &#123;&#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123; sealedClass* pInstance; pInstance = sealedClass::getInstance(); pInstance-&gt;deleteInstance(pInstance);&#125;</code></pre><h2 id="如何定义一个只能在堆上定义对象的类-栈上呢"><a href="#如何定义一个只能在堆上定义对象的类-栈上呢" class="headerlink" title="如何定义一个只能在堆上定义对象的类?栈上呢?"></a>如何定义一个只能在堆上定义对象的类?栈上呢?</h2><ul><li>只能在堆内存上实例化的类：将析构函数定义为private，在栈上不能自动调用析构函数，只能手动调用；也可以将构造函数定义为private。</li><li>只能在栈内存上实例化的类：将函数operator new和operator delete定义为private，这样使用new操作符创建对象时候，无法调用operator new，delete销毁对象也无法调用operator delete。</li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>basic knowledge</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统第一天</title>
    <link href="/2020/08/07/OS_day1_%E8%83%8C%E6%99%AF/"/>
    <url>/2020/08/07/OS_day1_%E8%83%8C%E6%99%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="what："><a href="#what：" class="headerlink" title="what："></a>what：</h2><p>操作系统在计算机中充当着大管家的角色。将计算资源分配给不同的用户程序使用。</p><h2 id="why："><a href="#why：" class="headerlink" title="why："></a>why：</h2><p>1 从开发角度来看：服务端开发，Unix-like OS占比近70%；客户端开发，安卓基于linux内核</p><p>2 从应用生态的角度来看：云计算，容器，大数据等技术都是基于linux</p><p>3 linux作为产品，本身提供了数据结构和设计模式的最佳实践。比如文件操作，涉及到分层机制。</p><p>4 自己的观点：要想开发性能优秀的程序，就需要对操作系统有深入理解。</p><h2 id="how："><a href="#how：" class="headerlink" title="how："></a>how：</h2><p>1 结合故事的方式</p><p>2 结合图解</p><h2 id="where-you-are-what-is-your-goal"><a href="#where-you-are-what-is-your-goal" class="headerlink" title="where you are ?  what is your goal ?"></a>where you are ?  what is your goal ?</h2><p><a href="https://time.geekbang.org/column/article/87111">点击测试以下自己的水平</a></p><p>The test will provide you a underlying knowledge network.</p><p>This course will help you how to achieve your goal and become better.</p><h2 id="The-Path-to-Master-Linux"><a href="#The-Path-to-Master-Linux" class="headerlink" title="The Path to Master Linux:"></a>The Path to Master Linux:</h2><p>会当凌绝顶，一览众山小。</p><p>step1：抛弃旧习惯，熟练使用命令行。tools：《鸟哥私房菜》</p><p>美丽的风景：例如一些很有技巧的命令 sed 和 awk、很神奇的正则表达式、灵活的管道和 grep、强大的 bash。你可以自动化地做一些事情了，例如处理一些数据，会比你使用 Excel 要又快又准，关键是不用框框点点，在后台就能完成一系列操作。在处理数据的同时，你还可以干别的事情，半夜处理数据，第二天早上发个邮件报告，这都是 Excel 很难做到的事情</p><p>step2：通过系统调用或者 glibc，学会自己进行程序设计。tools：《UNIX 环境高级编程》</p><p>你平时用的一个简单的命令行，却需要 N 个系统调用组合才能完成。其中每个系统调用都要进行深入地学习、读文档、做实验。</p><p>step3：了解 Linux 内核机制，反复研习重点突破。（重点）tools： 《深入理解 LINUX 内核》</p><p>Linux 内核机制也非常复杂，而且其中相互关联。比如说，进程运行要分配内存，内存映射涉及文件的关联，文件的读写需要经过块设备，从文件中加载代码才能运行起来进程。这些知识点要反复对照，才能理清。</p><p>step4： 阅读 Linux 内核代码，聚焦核心逻辑和场景</p><p>当你在工作中需要重点研究某方面技术的时候，如果涉及内核，这个时候仅仅了解原理已经不够了，你需要看这部分的代码。你就可以有针对性地去做课题，把所学和你现在做的东西结合起来重点突破。例如你是研究虚拟化的，就重点看 KVM 的部分；如果你是研究网络的，就重点看内核协议栈的部分。</p><p>step5： </p><h2 id="目标拆解："><a href="#目标拆解：" class="headerlink" title="目标拆解："></a>目标拆解：</h2><p>linux可以分为几个功能模块：</p><p>进程管理；内存管理；文件系统；网络；设备</p>]]></content>
    
    
    <categories>
      
      <category>Operating System</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统第一天</title>
    <link href="/2020/08/07/OS_day2_Linux%E7%BB%BC%E8%BF%B0/"/>
    <url>/2020/08/07/OS_day2_Linux%E7%BB%BC%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p>以打开qq为例，了解整个流程。</p>]]></content>
    
    
    <categories>
      
      <category>Operating System</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统第一天</title>
    <link href="/2020/08/07/OS_day3_%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    <url>/2020/08/07/OS_day3_%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>Linux 里是“命令行 + 文件”模式</p><p>useradd</p><p>man useradd </p><p>命令行 + 文件</p>]]></content>
    
    
    <categories>
      
      <category>Operating System</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
